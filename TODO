### Guidance ###

Start with critical functions. Leave added functionality for after I can click and have an episode I've watched recorded.
Everything else can wait.

FIX: SQLite can't recognize tables already exist, right now.

Stuff that is trivial to implement:
Option: display last episode watched, or next episode to watch?

Stuff that can wait:
Listing layout: switch to table instead of HBoxes in VBoxes
Episode voting
Episode name recording
metadata functions
Next episode suggestion - looks at your DB and suggests three shows to watch next, weighting Watching shows by percentage progress, completed shows by rewatch value and # of times rewatched (tails better than bell), and other shows by length?
Detect movies and put them on their own notebook tab
Sanity checking for all input values, specifically those expect to be between, e.g., 0..10.
Install script that checks for and pulls unsatisfied Perl dependencies?
When building title rows, put in button(s) for moving to another status
Allow titles to be arranged in different orders
Options dialog box can probably wait
Storage of alternate titles (including CJK support)
Changing options immediately updates all tabs (requires hash of boxes to update)
The project still needs Anime and Manga objects. They will be useful for an option to preserve network traffic rather than memory footprint.
Main context should create (and pass down) global references for the raows that'll go in the display tables, so that the program can rearrange the display without making SQL calls every time. But only if the abovementioned option is chosen.
Manga storing of volumes, and automatic update of chapter count when a volume is marked complete
Perhaps disambiguation list should be loaded from an external file, so the user can modify it without diving into code?
Make sure all SQL update functions use prepareFromHash (for uniformity and easier debugging)
